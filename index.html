<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Multi-Dimensional Audio Rating (Prototype)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { font-family: system-ui, -apple-system, 'Segoe UI', Roboto, Arial; margin: 16px; }
    #container { position: relative; width: 100%; max-width: 2000px; margin: 0 auto; }
    #waveform { position: relative; background: #fafafa; border: 1px solid #ddd; }
    canvas#overlay { position: absolute; top: 0; left: 0; z-index: 5; pointer-events: auto; }
    .controls { margin-top: 8px; display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    button { padding: 6px 10px; border-radius:6px; border:1px solid #bbb; background:#fff; cursor:pointer; }
    button:active{ transform: translateY(1px); }
    label { font-size:13px; color:#333; }
    #info { margin-top:8px; font-size:13px; color:#444; }
    .small { font-size:12px; color:#666; }
    #rating-legend { margin-left: 12px; display:flex; gap:6px; align-items:center; flex-wrap:wrap; }
    .legend-item { padding:4px 6px; border-radius:4px; font-size:12px; color:#fff; }
    .dimension-buttons { margin-bottom: 8px; display:flex; gap:6px; flex-wrap:wrap; }
    input[type=range] { width: 100%; }
    #slider-container { width: 100%; max-width: 2000px; margin-top:6px; }

    .dimension-buttons button.active {
      background: #2563eb;
      color: white;
      border-color: #1e40af;
    }
  </style>
</head>
<body>
  <h2>Multi-Dimensional Audio Rating (Prototype)</h2>
  <p class="small">Double-click waveform to split a segment. Drag inside a segment vertically to change rating. Drag boundaries horizontally to move them. Right-click a split handle to delete it. Use the slider below to jump in audio.</p>

  <div class="dimension-buttons">
    <button data-dim="valence">Valence</button>
    <button data-dim="arousal">Arousal</button>
    <button data-dim="enjoyment">Enjoyment</button>
    <button data-dim="is_cool">Is Cool</button>
  </div>

  <div id="container">
    <div id="waveform"></div>
    <canvas id="overlay"></canvas>
  </div>

  <div class="controls" id="rating-info">
    <label>Step levels: <strong id="steps-label"></strong></label>
    <div id="rating-legend"></div>
    <button id="export-btn">Download CSV</button>
  </div>

  <div id="slider-container">
    <input type="range" id="time-slider" min="0" max="1" step="0.001" value="0">
  </div>

  <div class="controls" id="audio-controls">
    <button id="play">Play</button>
    <button id="stop">Stop</button>
  </div>

  <div id="info">
    <span id="status">Loading...</span>
  </div>

  <script type="module">
    (() => {
      import('https://unpkg.com/wavesurfer.js@7.0.0/dist/wavesurfer.esm.js').then(({ default: WaveSurfer }) => {

        const AUDIO_URL = './demo.wav';

        // DIMENSIONS CONFIG
        const dimensionDefinition = {
          valence: { num_values: 10 },
          arousal: { num_values: 5 },
          enjoyment: { num_values: 10 },
          is_cool: { num_values: 2 }
        };

        let dimensionData = {};
        let currentDimension = 'valence';
        const segmentsDefault = (num_values) => [{ start:0, end:1e9, value: Math.floor(num_values/2) }];

        for (const dim in dimensionDefinition){
          dimensionData[dim] = segmentsDefault(dimensionDefinition[dim].num_values);
        }

        const container = document.getElementById('container');
        const waveformEl = document.getElementById('waveform');
        const overlay = document.getElementById('overlay');
        const playBtn = document.getElementById('play');
        const stopBtn = document.getElementById('stop');
        const status = document.getElementById('status');
        const stepsLabel = document.getElementById('steps-label');
        const legend = document.getElementById('rating-legend');
        const timeSlider = document.getElementById('time-slider');
        const dimButtons = document.querySelectorAll('.dimension-buttons button');

        const ctx = overlay.getContext('2d');
        const CANVAS_HEIGHT = 140;
        const HANDLE_HIT = 8;

        let segments = dimensionData[currentDimension];

        function durationOrOne(){ const d=wavesurfer.getDuration(); return (d&&isFinite(d))?d:1;}
        function timeToX(time){return Math.max(0,Math.min(overlay.width,(time/durationOrOne())*overlay.width));}
        function xToTime(x){return Math.max(0,Math.min(durationOrOne(), (x/overlay.width)*durationOrOne()));}

        function findSegmentIndexAtTime(time){ for(let i=0;i<segments.length;i++){if(segments[i].start<=time && time<=segments[i].end) return i;} return -1; }

        function colorForRating(r, num_values){ const t = r/(num_values-1||1); const hue = 220-(220-10)*t; return `hsl(${hue} 80% 50% / 0.45)`; }

        function updateLegend(num_values){
          legend.innerHTML = '';
          for(let r=num_values-1;r>=0;r--){
            const item = document.createElement('div');
            item.className='legend-item';
            item.style.background=colorForRating(r,num_values).replace('/ 0.45)','/1)');
            item.textContent=r;
            legend.appendChild(item);
          }
          stepsLabel.textContent=num_values;
        }

        function resizeOverlay(){
          const rect = waveformEl.getBoundingClientRect();
          overlay.width = Math.max(100, rect.width);
          overlay.height = CANVAS_HEIGHT;
          overlay.style.width = rect.width+'px';
          overlay.style.height = CANVAS_HEIGHT+'px';
          overlay.style.left = waveformEl.offsetLeft+'px';
          drawAll();
        }

        window.addEventListener('resize',()=>{setTimeout(resizeOverlay,120);});

        function drawAll(){
          ctx.clearRect(0,0,overlay.width,overlay.height);
          const h=overlay.height;
          const w=overlay.width;
          const num_steps = dimensionDefinition[currentDimension].num_values;

          for(let s=0;s<num_steps;s++){
            const y=h-(s/(num_steps-1))*h;
            ctx.beginPath();
            ctx.moveTo(0,y); ctx.lineTo(w,y);
            ctx.lineWidth=(s===Math.floor((num_steps-1)/2))?1.2:0.7;
            ctx.strokeStyle='rgba(0,0,0,0.06)';
            ctx.stroke();
            ctx.fillStyle='rgba(0,0,0,0.6)';
            ctx.font='12px system-ui, Arial';
            ctx.fillText(String(s),6,Math.max(12,y-4));
          }

          segments.forEach((seg,idx)=>{
            const x1=timeToX(seg.start), x2=timeToX(seg.end);
            const heightFromTop=(1-(seg.value/(num_steps-1)))*h;
            const color=colorForRating(seg.value,num_steps);
            ctx.fillStyle=color;
            ctx.fillRect(x1,heightFromTop,Math.max(2,x2-x1),h-heightFromTop);
            ctx.strokeStyle='rgba(0,0,0,0.08)';
            ctx.lineWidth=1;
            ctx.strokeRect(x1+0.5,heightFromTop+0.5,Math.max(1,x2-x1-1),h-heightFromTop-1);
            ctx.fillStyle='rgba(0,0,0,0.85)';
            ctx.font='12px system-ui, Arial';
            ctx.fillText(`${seg.value}`,x1+6,Math.max(12,heightFromTop+12));

            if(idx>0){
              const hx=x1;
              ctx.fillStyle='rgba(0,0,0,0.6)';
              ctx.fillRect(hx-1,0,2,h);
            }
          });

          if(wavesurfer.isReady){
            const t=wavesurfer.getCurrentTime();
            const x=timeToX(t);
            ctx.beginPath();
            ctx.moveTo(x+0.5,0);
            ctx.lineTo(x+0.5,h);
            ctx.strokeStyle='rgba(255,0,0,0.8)';
            ctx.lineWidth=2;
            ctx.stroke();
          }

          timeSlider.value = wavesurfer.getCurrentTime();
        }

        let pointerDown=false, activeSegIndex=null, activeHandle=null, lastPointerX=0, lastPointerY=0;

        function hitTestHandle(x){ const time=xToTime(x); for(let i=1;i<segments.length;i++){const bx=timeToX(segments[i].start); if(Math.abs(bx-x)<=HANDLE_HIT)return{i:i};} return null;}

        overlay.addEventListener('pointerdown',(ev)=>{
          ev.preventDefault();
          const rect=overlay.getBoundingClientRect();
          const x=ev.clientX-rect.left, y=ev.clientY-rect.top;
          lastPointerX=x; lastPointerY=y; pointerDown=true;

          const handle=hitTestHandle(x);
          if(handle){
            activeHandle={index:handle.i,startSeg:handle.i-1,endSeg:handle.i};
            overlay.setPointerCapture(ev.pointerId);
            return;
          }

          const time=xToTime(x);
          const si=findSegmentIndexAtTime(time);
          if(si>=0){ activeSegIndex=si; overlay.setPointerCapture(ev.pointerId);}
          drawAll();
        });

        overlay.addEventListener('pointermove',(ev)=>{
          if(!pointerDown)return;
          const rect=overlay.getBoundingClientRect();
          const x=ev.clientX-rect.left, y=ev.clientY-rect.top;
          const dx=x-lastPointerX, dy=y-lastPointerY; lastPointerX=x; lastPointerY=y;

          if(activeHandle){
            const time=xToTime(x), idx=activeHandle.index;
            const leftSeg=segments[activeHandle.startSeg], rightSeg=segments[activeHandle.endSeg];
            const epsilon=0.02;
            const newBoundary=Math.max(leftSeg.start+epsilon,Math.min(rightSeg.end-epsilon,time));
            leftSeg.end=newBoundary; rightSeg.start=newBoundary;
            drawAll();
            return;
          }

          if(activeSegIndex!=null){
            const seg=segments[activeSegIndex]; const h=overlay.height;
            const ratio=1-(y/h);
            let raw=Math.round(ratio*(dimensionDefinition[currentDimension].num_values-1));
            raw=Math.max(0,Math.min(dimensionDefinition[currentDimension].num_values-1,raw));
            seg.value=raw; drawAll(); return;
          }
        });

        overlay.addEventListener('pointerup',(ev)=>{ pointerDown=false; activeSegIndex=null; activeHandle=null; try{overlay.releasePointerCapture(ev.pointerId);}catch{} drawAll(); });

        overlay.addEventListener('dblclick',(ev)=>{
          ev.preventDefault(); const rect=overlay.getBoundingClientRect(); const x=ev.clientX-rect.left;
          const time=xToTime(x); const si=findSegmentIndexAtTime(time); if(si===-1)return;
          const seg=segments[si]; const MIN_SEG=0.08;
          if((time-seg.start)<MIN_SEG||(seg.end-time)<MIN_SEG)return;
          const right={start:time,end:seg.end,value:seg.value}; seg.end=time; segments.splice(si+1,0,right); drawAll();
        });

        overlay.addEventListener('contextmenu',(ev)=>{
          ev.preventDefault(); const rect=overlay.getBoundingClientRect(); const x=ev.clientX-rect.left; const handle=hitTestHandle(x);
          if(handle){ const i=handle.i; const left=segments[i-1], right=segments[i]; left.end=right.end; segments.splice(i,1); drawAll(); }
        });

        let renderLoop=null;
        function startRenderLoop(){ if(renderLoop)cancelAnimationFrame(renderLoop); function loop(){ drawAll(); renderLoop=requestAnimationFrame(loop);} renderLoop=requestAnimationFrame(loop); }

        const wavesurfer=WaveSurfer.create({
          container:'#waveform',
          waveColor:'#bfc8d6',
          progressColor:'#6b46c1',
          height:CANVAS_HEIGHT,
          scrollParent:true
        });

        wavesurfer.load(AUDIO_URL);
        wavesurfer.on('ready',()=>{
          const duration=wavesurfer.getDuration();
          for(const dim in dimensionData){dimensionData[dim].forEach(s=>{if(s.end>duration)s.end=duration;});}
          resizeOverlay();
          status.textContent=`Audio duration: ${duration.toFixed(2)}s. Press Space to Play/Pause.`;
          wavesurfer.isReady=true;
          startRenderLoop();
          timeSlider.max=duration;
        });

        wavesurfer.on('finish',()=>{playBtn.textContent='Play';});

        // ✅ Play/Pause controls using events
        playBtn.addEventListener('click',()=>{wavesurfer.playPause();});
        wavesurfer.on('play',()=>{playBtn.textContent='Pause';});
        wavesurfer.on('pause',()=>{playBtn.textContent='Play';});

        stopBtn.addEventListener('click',()=>{wavesurfer.stop(); playBtn.textContent='Play';});

        // ✅ Spacebar now updates button correctly
        window.addEventListener('keydown',(ev)=>{
          if(ev.code==='Space'&&document.activeElement.tagName!=='INPUT'&&document.activeElement.tagName!=='TEXTAREA'){
            ev.preventDefault();
            wavesurfer.playPause();
          }
        });

        timeSlider.addEventListener('input',()=>{
          const t=parseFloat(timeSlider.value);
          wavesurfer.seekTo(t/durationOrOne());
        });

        function updateActiveButton() {
          dimButtons.forEach(btn => {
            btn.classList.toggle('active', btn.dataset.dim === currentDimension);
          });
        }

        dimButtons.forEach(btn=>{
          btn.addEventListener('click',()=>{
            dimensionData[currentDimension] = JSON.parse(JSON.stringify(segments));
            currentDimension = btn.dataset.dim;
            segments = dimensionData[currentDimension];
            updateLegend(dimensionDefinition[currentDimension].num_values);
            updateActiveButton();
            drawAll();
          });
        });

        updateLegend(dimensionDefinition[currentDimension].num_values);
        updateActiveButton();

        document.getElementById('export-btn').addEventListener('click', () => {
          let csvContent = "data:text/csv;charset=utf-8,dimension,start,end,value\n";
          for (const dim in dimensionData) {
              dimensionData[dim].forEach(seg => {
                  csvContent += `${dim},${seg.start.toFixed(2)},${seg.end.toFixed(2)},${seg.value}\n`;
              });
          }
          const encodedUri = encodeURI(csvContent);
          const link = document.createElement("a");
          link.setAttribute("href", encodedUri);
          link.setAttribute("download", "ratings.csv");
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
        });

        setTimeout(()=>resizeOverlay(),400);

      });
    })();
  </script>
</body>
</html>
