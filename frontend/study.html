<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Music Rating Study</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="stylesheet" href="./audio_rating.css" />
  <style>
    body {
      font-family: system-ui, -apple-system, 'Segoe UI', Roboto, Arial;
      margin: 16px;
      max-width: 1000px;
      margin-left: auto;
      margin-right: auto;
    }
    .study-phase {
      display: none;
      opacity: 0;
      transition: opacity 0.3s ease;
    }
    .study-phase.active {
      display: block;
      opacity: 1;
    }
    .thank-you { text-align: center; padding: 40px; }
    .instructions { line-height: 1.6; }
    button {
      padding: 10px 20px;
      margin: 10px 5px;
      border: 1px solid #bbb;
      border-radius: 6px;
      background: #fff;
      cursor: pointer;
    }
    button.primary { background: #2563eb; color: white; border-color: #1e40af; }
    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    button.song-nav {
      padding: 6px 12px;
      margin: 2px;
      font-size: 0.9em;
    }
    button.song-nav.active {
      background: #2563eb;
      color: white;
      border-color: #1e40af;
    }

    /* Backend status indicator */
    .backend-status {
      position: fixed;
      top: 10px;
      right: 10px;
      padding: 8px 12px;
      border-radius: 6px;
      font-size: 0.9em;
      z-index: 1000;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .backend-status.online {
      background: #dcfce7;
      border: 1px solid #bbf7d0;
      color: #059669;
    }
    .backend-status.offline {
      background: #fef2f2;
      border: 1px solid #fecaca;
      color: #dc2626;
    }
    .backend-status.connecting {
      background: #fef9c3;
      border: 1px solid #fde047;
      color: #ca8a04;
    }

    /* Song navigation */
    .song-navigation {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin: 15px 0;
      padding: 15px;
      background: #f8fafc;
      border-radius: 8px;
      border: 1px solid #e2e8f0;
    }
    .song-navigation h4 {
      margin: 0 0 10px 0;
      width: 100%;
      color: #475569;
    }

    /* Status messages */
    .error-message {
      color: #dc2626;
      background: #fef2f2;
      border: 1px solid #fecaca;
      padding: 10px;
      border-radius: 6px;
      margin: 10px 0;
    }
    .success-message {
      color: #059669;
      background: #f0fdf4;
      border: 1px solid #bbf7d0;
      padding: 10px;
      border-radius: 6px;
      margin: 10px 0;
    }
    .warning-message {
      color: #ca8a04;
      background: #fef9c3;
      border: 1px solid #fde047;
      padding: 10px;
      border-radius: 6px;
      margin: 10px 0;
    }

    .loading-shade {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(255,255,255,0.8);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 10;
    }
    .loading-shade.active {
      display: flex;
    }

    /* Hide elements that should be hidden */
    #backend-notice,
    #download-section {
      display: none;
    }

    .progress-info {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
      padding-bottom: 10px;
      border-bottom: 1px solid #e2e8f0;
    }

    /* Song navigation with completion indicators */
    .song-nav-container {
      position: relative;
      display: inline-block;
      margin: 2px;
    }

    .song-nav {
      padding: 6px 12px;
      margin: 0;
      font-size: 0.9em;
      position: relative;
    }

    .song-nav.active {
      background: #2563eb;
      color: white;
      border-color: #1e40af;
    }

    /* Updated Completion Status Styles */
    .completion-indicator.not-rated { background: #ef4444; } /* Red */
    .completion-indicator.ready { background: #facc15; }     /* Yellow */
    .completion-indicator.saved { background: #10b981; }     /* Green */

    /* Tooltip text update via JS attribute */
    .song-nav-container:hover .completion-indicator::after {
      content: attr(data-tooltip);
      /* ... rest of your existing tooltip CSS ... */
    }

    /* Completion status tooltip */
    .song-nav-container:hover .completion-indicator::after {
      content: attr(title);
      position: absolute;
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 12px;
      white-space: nowrap;
      z-index: 100;
      margin-bottom: 5px;
    }
  </style>
</head>
<body>
  <div id="backend-status" class="backend-status connecting">Checking backend...</div>

  <div id="study-container">
    <!-- Instructions Phase -->
    <div id="instructions-phase" class="study-phase active">
      <h2>Music Rating Study</h2>
      <div class="instructions">
        <p>Welcome to our music perception study!</p>
        <div id="backend-notice">
          <strong>⚠️ Offline Mode:</strong> Backend server not available. Ratings will be saved locally only.
        </div>
        <p>You will be asked to rate <span id="song-count">several</span> songs on different dimensions.</p>
        <p>For each song:</p>
        <ul>
          <li>Listen to the audio and rate it as you go</li>
          <li>Split the song into segments by double-clicking on the waveform</li>
          <li>Drag vertically within segments to adjust ratings</li>
          <li>Drag segment boundaries horizontally to adjust timing</li>
          <li>Right-click boundaries to delete them</li>
        </ul>
        <p>Click "Begin Study" when you're ready to start.</p>
      </div>
      <button id="begin-study" class="primary">Begin Study</button>
    </div>

    <!-- Rating Phase -->
    <div id="rating-phase" class="study-phase">
      <div class="progress-info">
        <h3 style="margin: 0;">Song <span id="current-song-number">1</span> of <span id="total-songs">1</span></h3>
        <div id="song-status" style="font-size: 0.9em; color: #666;"></div>
      </div>

      <div class="song-navigation">
        <h4>Select a song:</h4>
        <div id="song-list"></div>
      </div>

      <div id="rating-widget-container"></div>


      <div style="margin-top: 20px; text-align: center;">
        <button id="submit-rating" class="primary">Save Rating</button>
      </div>
      <div id="storage-status" style="margin-top: 10px; font-size: 0.9em; color: #666;"></div>

      <div id="status-messages" style="margin-top: 10px;"></div>
      <div class="loading-shade" id="loading-overlay">Loading...</div>
    </div>

    <!-- Completion Phase -->
    <div id="completion-phase" class="study-phase">
      <div class="thank-you">
        <h2>Thank You!</h2>
        <p id="completion-message">You have completed all songs in this study.</p>
        <div id="download-section">
          <button id="download-data" class="primary">Download All Ratings</button>
          <p style="font-size: 0.9em; margin-top: 10px;">Save this file to preserve your ratings.</p>
        </div>
      </div>
    </div>
  </div>

  <script src="./ar_settings.js"></script>
  <script type="module">
    import { AudioRatingWidget } from './audio_rating.js';

    // DEFAULT CONFIG - Updated to match backend format
    const DEFAULT_STUDY_CONFIG = {
      name: "Default Study",
      name_short: "default",
      description: "Default study for music aesthetics research",
      songs_to_rate: [
        { media_url: "demo.wav", display_name: "Demo Song" },
        { media_url: "demo2.wav", display_name: "Demo Song 2" }
      ],
      rating_dimensions: [
        { dimension_title: "valence", num_values: 8 },
        { dimension_title: "arousal", num_values: 5 },
        { dimension_title: "enjoyment", num_values: 10 },
        { dimension_title: "is_cool", num_values: 2 }
      ],
      study_participant_ids: [],
      allow_unlisted_participants: true,
      data_collection_start: "2024-01-01T00:00:00Z",
      data_collection_end: "2026-12-31T23:59:59Z"
    };



    class StudyCoordinator {
  constructor() {
    this.studyConfig = DEFAULT_STUDY_CONFIG;
    this.currentSongIndex = 0;
    this.uid = this.getOrCreateUID();
    this.studyName = this.getStudyName();
    this.widget = null;
    this.isLoading = false;
    this.backendAvailable = false;
    this.backendChecked = false;

    // Track which songs are synced with server
    this.songSyncStatus = {}; // 'unsaved', 'synced', or 'modified'

    this.localStorageKey = `audio_rating_study_${this.studyName}_${this.uid}`;
    this.localRatings = this.loadLocalRatings();

    this.init();
  }

  destroy() {
    if (this.widget) {
      this.widget.destroy();
      this.widget = null;
    }
  }

  getDefaultValueForDimension(dimensionName) {
    const dimConfig = this.studyConfig.rating_dimensions[dimensionName];
    return Math.floor(dimConfig.num_values / 2);
  }

  getOrCreateUID() {
    const urlParams = new URLSearchParams(window.location.search);
    let uid = urlParams.get('uid');

    if (!uid) {
      uid = 'uid_' + Math.random().toString(36).substr(2, 9);
      const newUrl = `${window.location.pathname}?uid=${uid}&study_name=${this.getStudyName()}`;
      window.history.replaceState({}, '', newUrl);
    }

    return uid;
  }

  isSongCompletelyRated(songIndex) {
    // For current song being edited, check widget data
    if (songIndex === this.currentSongIndex && this.widget) {
      const currentData = this.widget.getData();
      return this.checkRatingDataComplete(currentData).isComplete;
    }

    // Otherwise check localStorage
    const songKey = `${this.studyName}_song_${songIndex}`;
    const songData = this.localRatings[songKey];

    if (!songData || !songData.data) {
      return false;
    }

    return this.checkRatingDataComplete(songData.data).isComplete;
  }

  checkRatingDataComplete(ratingData) {
    if (!ratingData || Object.keys(ratingData).length === 0) {
      return { isComplete: false, missingDimensions: Object.keys(this.studyConfig.rating_dimensions) };
    }

    const requiredDimensions = Object.keys(this.studyConfig.rating_dimensions);
    const missingDimensions = [];

    requiredDimensions.forEach(dim => {
      if (!ratingData[dim] || !Array.isArray(ratingData[dim]) || ratingData[dim].length === 0) {
        missingDimensions.push(dim);
        return;
      }

      const defaultValue = this.getDefaultValueForDimension(dim);
      const segments = ratingData[dim];

      // If user added segments (more than 1), it's modified
      if (segments.length > 1) {
        return;
      }

      // Check the single segment
      const segment = segments[0];
      if (!segment || segment.value === undefined || segment.value === null) {
        missingDimensions.push(dim);
        return;
      }

      // If value differs from default, it's modified
      if (segment.value !== defaultValue) {
        return;
      }

      // If we get here, dimension still has default value
      missingDimensions.push(dim);
    });

    const isComplete = missingDimensions.length === 0;

    if(!isComplete) {
      console.log('Incomplete rating data, missing dimensions:', missingDimensions);
    }

    return {
      isComplete: isComplete,
      missingDimensions: missingDimensions
    };
  }

  updateAllUI() {
    this.updateSubmitButtonState();
    this.updateSongNavigationUI();
  }

  updateSubmitButtonState() {
    const submitBtn = document.getElementById('submit-rating');
    if (!submitBtn) return;

    if (!this.backendAvailable) {
      submitBtn.disabled = true;
      submitBtn.textContent = 'Server Unavailable';
      return;
    }

    if (!this.widget) {
      submitBtn.disabled = true;
      submitBtn.textContent = 'Loading...';
      return;
    }

    const ratingData = this.widget.getData();
    const result = this.checkRatingDataComplete(ratingData);

    if (result.isComplete) {
      if (this.songSyncStatus[this.currentSongIndex] === 'synced') {
        submitBtn.disabled = true;
        submitBtn.textContent = 'Already Saved to Server';
      } else {
        submitBtn.disabled = false;
        submitBtn.textContent = 'Save to Server';
      }
    } else {
      submitBtn.disabled = true;
      if (result.missingDimensions.length > 0) {
        submitBtn.textContent = `Rate: ${result.missingDimensions.join(', ')}`;
      } else {
        submitBtn.textContent = 'Complete all ratings to save';
      }
    }
  }

  getSongStatus(songIndex) {
    const isComplete = this.isSongCompletelyRated(songIndex);

    if (!isComplete) {
      return {
        status: 'incomplete',
        icon: '○',
        color: '#ef4444',
        label: 'Incomplete ratings'
      };
    } else if (this.songSyncStatus[songIndex] === 'synced') {
      return {
        status: 'saved',
        icon: '✓',
        color: '#10b981',
        label: 'Saved to server'
      };
    } else {
      return {
        status: 'ready',
        icon: '!',
        color: '#facc15',
        label: 'Fully rated and ready to submit'
      };
    }
  }

  updateSongNavigationUI() {
    const songListDiv = document.getElementById('song-list');
    songListDiv.innerHTML = '';

    this.studyConfig.songs_to_rate.forEach((song, index) => {
      const status = this.getSongStatus(index);

      const buttonContainer = document.createElement('div');
      buttonContainer.className = 'song-nav-container';

      const button = document.createElement('button');
      button.type = 'button';
      button.className = 'song-nav';
      button.textContent = `${index + 1}. ${song.display_name}`;
      button.dataset.index = index;

      if (index === this.currentSongIndex) {
        button.classList.add('active');
      }

      button.addEventListener('click', () => {
        this.loadSong(index);
      });

      const indicator = document.createElement('span');
      indicator.className = `completion-indicator ${status.status}`;
      indicator.title = status.label;
      indicator.textContent = status.icon;
      indicator.style.cssText = `
        position: absolute;
        top: -5px;
        right: -5px;
        width: 16px;
        height: 16px;
        border-radius: 50%;
        font-size: 10px;
        display: flex;
        align-items: center;
        justify-content: center;
        background: ${status.color};
        color: white;
        border: 1px solid white;
        box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        pointer-events: none;
      `;

      buttonContainer.appendChild(button);
      buttonContainer.appendChild(indicator);
      songListDiv.appendChild(buttonContainer);
    });
  }

  getStudyName() {
    const urlParams = new URLSearchParams(window.location.search);
    return urlParams.get('study_name') || 'default';
  }

  convertToWidgetFormat(backendConfig) {
    const ratingDimensions = {};
    backendConfig.rating_dimensions.forEach(dim => {
      ratingDimensions[dim.dimension_title] = { num_values: dim.num_values };
    });

    return {
      ...backendConfig,
      rating_dimensions: ratingDimensions
    };
  }

  async init() {
    await this.checkBackendAvailability();

    if (this.backendAvailable) {
      const configLoaded = await this.loadStudyConfigFromBackend();
      if (!configLoaded) {
        this.studyConfig = this.convertToWidgetFormat(DEFAULT_STUDY_CONFIG);
      }
    } else {
      this.showOfflineNotice();
      this.studyConfig = this.convertToWidgetFormat(DEFAULT_STUDY_CONFIG);
    }

    document.getElementById('song-count').textContent = this.studyConfig.songs_to_rate.length;
    document.getElementById('total-songs').textContent = this.studyConfig.songs_to_rate.length;

    this.updateSongNavigationUI();

    document.getElementById('begin-study').addEventListener('click', () => this.startRating());
    document.getElementById('submit-rating').addEventListener('click', () => this.submitRating());
    document.getElementById('download-data').addEventListener('click', () => this.downloadAllRatings());

    this.updateBackendStatus();
  }

  async checkBackendAvailability() {
    try {
      const response = await fetch(`${AR_SETTINGS.API_BASE_URL}`, {
        method: 'GET',
        headers: { 'Accept': 'application/json' }
      });

      this.backendAvailable = response.ok;
      this.backendChecked = true;
    } catch (error) {
      this.backendAvailable = false;
      this.backendChecked = true;
    }
  }

  async loadStudyConfigFromBackend() {
    try {
      const response = await fetch(
        `${AR_SETTINGS.API_BASE_URL}/participants/${this.uid}/studies/${this.studyName}/config`
      );

      if (response.ok) {
        const studyConfig = await response.json();
        this.studyConfig = this.convertToWidgetFormat(studyConfig);

        for (let i = 0; i < this.studyConfig.songs_to_rate.length; i++) {
          try {
            const ratingsResponse = await fetch(
              `${AR_SETTINGS.API_BASE_URL}/participants/${this.uid}/studies/${this.studyName}/songs/${i}/ratings`
            );

            if (ratingsResponse.ok) {
              const data = await ratingsResponse.json();
              const songKey = `${this.studyName}_song_${i}`;

              const backendRatings = {};
              if (data.ratings) {
                Object.keys(data.ratings).forEach(ratingName => {
                  backendRatings[ratingName] = data.ratings[ratingName].segments || [];
                });
              }

              this.localRatings[songKey] = {
                data: backendRatings,
                source: 'backend',
                timestamp: new Date().toISOString()
              };

              // Mark as synced
              this.songSyncStatus[i] = 'synced';
            }
          } catch (error) {
            console.log(`No backend ratings for song ${i}`, error);
          }
        }

        this.saveLocalRatings();

        return true;
      } else {
        this.showStatusMessage(`Failed to load study config: ${response.status}`, 'error');
        return false;
      }
    } catch (error) {
      console.warn('Failed to load config from backend:', error);
      return false;
    }
  }

  async startRating() {
    this.showPhase('rating-phase');
    await this.loadSong(this.currentSongIndex);
  }

  async loadSong(songIndex) {
    // Auto-save current song before switching
    if (this.widget) {
      await this.autoSaveCurrentSong();

      // If current song was synced, check if data changed
      if (this.songSyncStatus[this.currentSongIndex] === 'synced') {
        const currentData = this.widget.getData();
        const songKey = `${this.studyName}_song_${this.currentSongIndex}`;
        const savedData = this.localRatings[songKey];

        if (savedData && JSON.stringify(currentData) !== JSON.stringify(savedData.data)) {
          this.songSyncStatus[this.currentSongIndex] = 'modified';
          this.updateAllUI();
        }
      }

      this.widget.destroy();
      this.widget = null;
    }

    this.currentSongIndex = songIndex;
    const song = this.studyConfig.songs_to_rate[songIndex];

    document.getElementById('current-song-number').textContent = songIndex + 1;
    document.getElementById('song-status').textContent = `Currently rating: ${song.display_name}`;

    this.updateSongNavigationUI();
    this.clearStatusMessages();
    this.setLoading(true, true);

    try {
      const widgetContainer = document.getElementById('rating-widget-container');
      widgetContainer.innerHTML = '';

      this.widget = await AudioRatingWidget.create({
        container: '#rating-widget-container',
        audioUrl: song.media_url,
        rating_dimensions: this.studyConfig.rating_dimensions,
        height: 140,
        waveColor: '#bfc8d6',
        progressColor: '#6b46c1',
        with_instructions: false,
        with_volume_slider: true,
        with_step_labels_legend: true,
        show_download_button: false,
        show_timeline: true,
        title: song.display_name
      });

      const songKey = `${this.studyName}_song_${songIndex}`;
      if (this.localRatings[songKey]) {
        this.widget.setData(this.localRatings[songKey].data);
      }

      this.widget.on('change', () => {
        // If song was synced but user makes changes, mark as modified
        if (this.songSyncStatus[this.currentSongIndex] === 'synced') {
          this.songSyncStatus[this.currentSongIndex] = 'modified';
        }
        this.updateAllUI();
      });

      this.updateAllUI();

    } catch (error) {
      console.error('Error loading song:', error);
      this.showStatusMessage(`Error loading song "${song.display_name}". Please try again.`, 'error');
    } finally {
      this.setLoading(false, true);
    }
  }

  async autoSaveCurrentSong() {
    if (!this.widget) return;

    const ratingData = this.widget.getData();
    if (Object.keys(ratingData).length === 0) {
      return;
    }

    const songKey = this.getSongKey();
    const song = this.studyConfig.songs_to_rate[this.currentSongIndex];

    this.localRatings[songKey] = {
      data: ratingData,
      timestamp: new Date().toISOString(),
      study: this.studyName,
      songIndex: this.currentSongIndex,
      songName: song.display_name,
      songUrl: song.media_url,
      source: 'local'
    };

    try {
      this.saveLocalRatings();
    } catch (error) {
      console.error('Auto-save failed:', error);
    }
  }

  getSongKey() {
    return `${this.studyName}_song_${this.currentSongIndex}`;
  }

  loadLocalRatings() {
    try {
      const stored = localStorage.getItem(this.localStorageKey);
      return stored ? JSON.parse(stored) : {};
    } catch (error) {
      console.error('Error loading local ratings:', error);
      return {};
    }
  }

  saveLocalRatings() {
    try {
      localStorage.setItem(this.localStorageKey, JSON.stringify(this.localRatings));
      return true;
    } catch (error) {
      console.error('Error saving local ratings:', error);
      return false;
    }
  }

  async submitRating() {
    if (this.isLoading || !this.widget) return;

    const ratingData = this.widget.getData();
    if (Object.keys(ratingData).length === 0) {
      this.showStatusMessage('No ratings to save. Please rate the song first.', 'error');
      return;
    }

    const result = this.checkRatingDataComplete(ratingData);
    if (!result.isComplete) {
      this.showStatusMessage('Please complete all ratings before submitting.', 'error');
      return;
    }

    this.setLoading(true, false);
    this.clearStatusMessages();

    const songKey = this.getSongKey();
    const song = this.studyConfig.songs_to_rate[this.currentSongIndex];
    const submissionTimestamp = new Date().toISOString();

    // Save locally
    this.localRatings[songKey] = {
      data: ratingData,
      timestamp: submissionTimestamp,
      study: this.studyName,
      songIndex: this.currentSongIndex,
      songName: song.display_name,
      songUrl: song.media_url,
      source: 'local'
    };

    this.saveLocalRatings();
    this.updateAllUI();
    this.showStatusMessage('Rating saved locally', 'success');

    if (this.backendAvailable) {
      try {
        const backendUrl = `${AR_SETTINGS.API_BASE_URL}/participants/${this.uid}/studies/${this.studyName}/songs/${this.currentSongIndex}/ratings`;

        const response = await fetch(backendUrl, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            timestamp: submissionTimestamp,
            ratings: ratingData
          })
        });

        if (response.ok) {
          // Update sync status
          this.songSyncStatus[this.currentSongIndex] = 'synced';

          // Update source to backend
          this.localRatings[songKey].source = 'backend';
          this.saveLocalRatings();

          this.updateAllUI();
          this.showStatusMessage('Ratings saved to server!', 'success');
        } else {
          this.showStatusMessage('Saved locally, but server submission failed.', 'warning');
        }
      } catch (error) {
        this.showStatusMessage('Saved locally. Backend temporarily unavailable.', 'warning');
      }
    }

    this.setLoading(false, false);
  }

  updateBackendStatus() {
    const statusEl = document.getElementById('backend-status');
    const storageEl = document.getElementById('storage-status');

    if (!this.backendChecked) {
      statusEl.className = 'backend-status connecting';
      statusEl.textContent = 'Checking backend...';
      if (storageEl) storageEl.textContent = 'Checking connection...';
      return;
    }

    if (this.backendAvailable) {
      statusEl.className = 'backend-status online';
      statusEl.textContent = '✓ Backend connected';
      if (storageEl) storageEl.textContent = 'Ratings will be saved to server';
    } else {
      statusEl.className = 'backend-status offline';
      statusEl.textContent = '⚠ Backend offline';
      if (storageEl) storageEl.textContent = 'Ratings saved locally only';
    }
  }

  showOfflineNotice() {
    document.getElementById('backend-notice').style.display = 'block';

    const submitBtn = document.getElementById('submit-rating');
    if (submitBtn) {
      submitBtn.textContent = 'Save Locally';
    }
  }

  showStatusMessage(message, type = 'info') {
    const statusDiv = document.getElementById('status-messages');
    const messageDiv = document.createElement('div');
    messageDiv.className = `${type}-message`;
    messageDiv.textContent = message;
    statusDiv.appendChild(messageDiv);

    if (type === 'success' || type === 'warning') {
      setTimeout(() => {
        if (messageDiv.parentNode) messageDiv.remove();
      }, 5000);
    }
  }

  clearStatusMessages() {
    const statusDiv = document.getElementById('status-messages');
    statusDiv.innerHTML = '';
  }

  setLoading(loading, isSongLoading = false) {
    this.isLoading = loading;
    const submitBtn = document.getElementById('submit-rating');
    const loadingOverlay = document.getElementById('loading-overlay');

    if (submitBtn) {
      submitBtn.disabled = loading;
      submitBtn.textContent = loading ? 'Saving...' :
        (this.backendAvailable ? 'Save to Server' : 'Save Locally');
    }

    if (loadingOverlay) {
      if (loading && isSongLoading) {
        loadingOverlay.classList.add('active');
      } else {
        loadingOverlay.classList.remove('active');
      }
    }
  }

  completeStudy() {
    const hasLocalData = Object.keys(this.localRatings).length > 0;

    if (!this.backendAvailable && hasLocalData) {
      document.getElementById('completion-message').innerHTML = `
        You have completed all songs in this study.<br>
        <strong>Important:</strong> Your ratings are saved locally only.
      `;
      document.getElementById('download-section').style.display = 'block';
    }

    this.showPhase('completion-phase');
  }

  downloadAllRatings() {
    const dataStr = JSON.stringify(this.localRatings, null, 2);
    const dataBlob = new Blob([dataStr], { type: 'application/json' });
    const url = URL.createObjectURL(dataBlob);

    const link = document.createElement('a');
    link.href = url;
    link.download = `audio_ratings_${this.studyName}_${this.uid}_${new Date().toISOString().split('T')[0]}.json`;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);

    setTimeout(() => URL.revokeObjectURL(url), 100);
  }

  showPhase(phaseId) {
    document.querySelectorAll('.study-phase').forEach(phase => {
      phase.classList.remove('active');
    });

    document.getElementById(phaseId).classList.add('active');
  }
}

    // Initialize study when page loads
    const study = new StudyCoordinator();
    window.study = study; // For debugging

    // Global error handling
    window.addEventListener('error', function(event) {
      console.error('Global error:', event.error);
    });

    window.addEventListener('unhandledrejection', function(event) {
      console.error('Unhandled promise rejection:', event.reason);
    });
  </script>
</body>
</html>