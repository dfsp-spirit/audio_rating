<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Music Rating Study</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="stylesheet" href="./audio_rating.css" />
  <style>
    body {
      font-family: system-ui, -apple-system, 'Segoe UI', Roboto, Arial;
      margin: 16px;
      max-width: 1000px;
      margin-left: auto;
      margin-right: auto;
    }
    .study-phase {
      display: none;
      opacity: 0;
      transition: opacity 0.3s ease;
    }
    .study-phase.active {
      display: block;
      opacity: 1;
    }
    .thank-you { text-align: center; padding: 40px; }
    .instructions { line-height: 1.6; }
    button {
      padding: 10px 20px;
      margin: 10px 5px;
      border: 1px solid #bbb;
      border-radius: 6px;
      background: #fff;
      cursor: pointer;
    }
    button.primary { background: #2563eb; color: white; border-color: #1e40af; }
    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    button.song-nav {
      padding: 6px 12px;
      margin: 2px;
      font-size: 0.9em;
    }
    button.song-nav.active {
      background: #2563eb;
      color: white;
      border-color: #1e40af;
    }

    /* Backend status indicator */
    .backend-status {
      position: fixed;
      top: 10px;
      right: 10px;
      padding: 8px 12px;
      border-radius: 6px;
      font-size: 0.9em;
      z-index: 1000;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .backend-status.online {
      background: #dcfce7;
      border: 1px solid #bbf7d0;
      color: #059669;
    }
    .backend-status.offline {
      background: #fef2f2;
      border: 1px solid #fecaca;
      color: #dc2626;
    }
    .backend-status.connecting {
      background: #fef9c3;
      border: 1px solid #fde047;
      color: #ca8a04;
    }

    /* Song navigation */
    .song-navigation {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin: 15px 0;
      padding: 15px;
      background: #f8fafc;
      border-radius: 8px;
      border: 1px solid #e2e8f0;
    }
    .song-navigation h4 {
      margin: 0 0 10px 0;
      width: 100%;
      color: #475569;
    }

    /* Status messages */
    .error-message {
      color: #dc2626;
      background: #fef2f2;
      border: 1px solid #fecaca;
      padding: 10px;
      border-radius: 6px;
      margin: 10px 0;
    }
    .success-message {
      color: #059669;
      background: #f0fdf4;
      border: 1px solid #bbf7d0;
      padding: 10px;
      border-radius: 6px;
      margin: 10px 0;
    }
    .warning-message {
      color: #ca8a04;
      background: #fef9c3;
      border: 1px solid #fde047;
      padding: 10px;
      border-radius: 6px;
      margin: 10px 0;
    }

    .loading-shade {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(255,255,255,0.8);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 10;
    }
    .loading-shade.active {
      display: flex;
    }

    /* Hide elements that should be hidden */
    #backend-notice,
    #download-section {
      display: none;
    }

    .progress-info {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
      padding-bottom: 10px;
      border-bottom: 1px solid #e2e8f0;
    }

    /* Song navigation with completion indicators */
    .song-nav-container {
      position: relative;
      display: inline-block;
      margin: 2px;
    }

    .song-nav {
      padding: 6px 12px;
      margin: 0;
      font-size: 0.9em;
      position: relative;
    }

    .song-nav.active {
      background: #2563eb;
      color: white;
      border-color: #1e40af;
    }

    /* Completion status tooltip */
    .song-nav-container:hover .completion-indicator::after {
      content: attr(title);
      position: absolute;
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 12px;
      white-space: nowrap;
      z-index: 100;
      margin-bottom: 5px;
    }
  </style>
</head>
<body>
  <div id="backend-status" class="backend-status connecting">Checking backend...</div>

  <div id="study-container">
    <!-- Instructions Phase -->
    <div id="instructions-phase" class="study-phase active">
      <h2>Music Rating Study</h2>
      <div class="instructions">
        <p>Welcome to our music perception study!</p>
        <div id="backend-notice">
          <strong>⚠️ Offline Mode:</strong> Backend server not available. Ratings will be saved locally only.
        </div>
        <p>You will be asked to rate <span id="song-count">several</span> songs on different dimensions.</p>
        <p>For each song:</p>
        <ul>
          <li>Listen to the audio and rate it as you go</li>
          <li>Split the song into segments by double-clicking on the waveform</li>
          <li>Drag vertically within segments to adjust ratings</li>
          <li>Drag segment boundaries horizontally to adjust timing</li>
          <li>Right-click boundaries to delete them</li>
        </ul>
        <p>Click "Begin Study" when you're ready to start.</p>
      </div>
      <button id="begin-study" class="primary">Begin Study</button>
    </div>

    <!-- Rating Phase -->
    <div id="rating-phase" class="study-phase">
      <div class="progress-info">
        <h3 style="margin: 0;">Song <span id="current-song-number">1</span> of <span id="total-songs">1</span></h3>
        <div id="song-status" style="font-size: 0.9em; color: #666;"></div>
      </div>

      <div class="song-navigation">
        <h4>Select a song:</h4>
        <div id="song-list"></div>
      </div>

      <div id="rating-widget-container"></div>


      <div style="margin-top: 20px; text-align: center;">
        <button id="submit-rating" class="primary">Save Rating</button>
      </div>
      <div id="storage-status" style="margin-top: 10px; font-size: 0.9em; color: #666;"></div>

      <div id="status-messages" style="margin-top: 10px;"></div>
      <div class="loading-shade" id="loading-overlay">Loading...</div>
    </div>

    <!-- Completion Phase -->
    <div id="completion-phase" class="study-phase">
      <div class="thank-you">
        <h2>Thank You!</h2>
        <p id="completion-message">You have completed all songs in this study.</p>
        <div id="download-section">
          <button id="download-data" class="primary">Download All Ratings</button>
          <p style="font-size: 0.9em; margin-top: 10px;">Save this file to preserve your ratings.</p>
        </div>
      </div>
    </div>
  </div>

  <script src="./ar_settings.js"></script>
  <script type="module">
    import { AudioRatingWidget } from './audio_rating.js';

    // DEFAULT CONFIG - Updated to match backend format
    const DEFAULT_STUDY_CONFIG = {
      name: "Default Study",
      name_short: "default",
      description: "Default study for music aesthetics research",
      songs_to_rate: [
        { media_url: "demo.wav", display_name: "Demo Song" },
        { media_url: "demo2.wav", display_name: "Demo Song 2" }
      ],
      rating_dimensions: [
        { dimension_title: "valence", num_values: 8 },
        { dimension_title: "arousal", num_values: 5 },
        { dimension_title: "enjoyment", num_values: 10 },
        { dimension_title: "is_cool", num_values: 2 }
      ],
      study_participant_ids: [],
      allow_unlisted_participants: true,
      data_collection_start: "2024-01-01T00:00:00Z",
      data_collection_end: "2026-12-31T23:59:59Z"
    };

    class StudyCoordinator {
      constructor() {
        this.studyConfig = DEFAULT_STUDY_CONFIG;
        this.currentSongIndex = 0;
        this.uid = this.getOrCreateUID();
        this.studyName = this.getStudyName();
        this.widget = null;
        this.isLoading = false;
        this.backendAvailable = false;
        this.backendChecked = false;
        this.songCompletionStatus = {}; // Track which songs are fully rated

        this.localStorageKey = `audio_rating_study_${this.studyName}_${this.uid}`;
        this.localRatings = this.loadLocalRatings();

        this.init();
      }

      destroy() {
        if (this.widget) {
          this.widget.destroy();
          this.widget = null;
        }
      }

      getDefaultValueForDimension(dimensionName) {
        const dimConfig = this.studyConfig.rating_dimensions[dimensionName];
        return Math.floor(dimConfig.num_values / 2);
      }

      getOrCreateUID() {
        const urlParams = new URLSearchParams(window.location.search);
        let uid = urlParams.get('uid');

        if (!uid) {
          // Generate random UID
          uid = 'uid_' + Math.random().toString(36).substr(2, 9);
          const newUrl = `${window.location.pathname}?uid=${uid}&study_name=${this.getStudyName()}`;
          window.history.replaceState({}, '', newUrl);
        }

        return uid;
      }


      isSongCompletelyRated(songIndex = this.currentSongIndex) {
        // If we're checking the current song and have widget data, use that
        if (songIndex === this.currentSongIndex && this.widget) {
          const ratingData = this.widget.getData();
          const result = this.checkRatingDataComplete(ratingData);
          return result.isComplete;
        }

        // Otherwise check localStorage
        const songKey = `${this.studyName}_song_${songIndex}`;
        if (this.localRatings[songKey] && this.localRatings[songKey].data) {
          const songData = this.localRatings[songKey].data;
          const result = this.checkRatingDataComplete(songData);
          return result.isComplete;
        }

        return false;
      }

      // Replace checkRatingDataComplete with this:
      checkRatingDataComplete(ratingData) {
        if (!ratingData || Object.keys(ratingData).length === 0) {
          return { isComplete: false, missingDimensions: Object.keys(this.studyConfig.rating_dimensions) };
        }

        const requiredDimensions = Object.keys(this.studyConfig.rating_dimensions);
        const missingDimensions = [];

        requiredDimensions.forEach(dim => {
          if (!ratingData[dim] || !Array.isArray(ratingData[dim]) || ratingData[dim].length === 0) {
            missingDimensions.push(dim);
            return;
          }

          const defaultValue = this.getDefaultValueForDimension(dim);
          const segments = ratingData[dim];

          // If user added segments (more than 1), it's modified
          if (segments.length > 1) {
            return; // This dimension is OK
          }

          // Check the single segment
          const segment = segments[0];
          if (!segment || segment.value === undefined || segment.value === null) {
            missingDimensions.push(dim);
            return;
          }

          // If value differs from default, it's modified
          if (segment.value !== defaultValue) {
            return; // This dimension is OK
          }

          // If we get here, dimension still has default value
          missingDimensions.push(dim);
        });

        const isComplete = missingDimensions.length === 0;

        if(!isComplete) {
          console.log('Incomplete rating data, missing dimensions:', missingDimensions);
        }

        return {
          isComplete: isComplete,
          missingDimensions: missingDimensions
        };
      }

      // Add this method after the checkRatingDataComplete method:
      async autoSaveCurrentSong() {
        if (!this.widget) return;

        const ratingData = this.widget.getData();
        if (Object.keys(ratingData).length === 0) {
          return;
        }

        const songKey = this.getSongKey();
        const song = this.studyConfig.songs_to_rate[this.currentSongIndex];
        const timestamp = new Date().toISOString();

        this.localRatings[songKey] = {
          data: ratingData,
          timestamp: timestamp,
          study: this.studyName,
          songIndex: this.currentSongIndex,
          songName: song.display_name,
          songUrl: song.media_url,
          source: 'local'
        };

        try {
          this.saveLocalRatings();
          console.log('Auto-saved song', this.currentSongIndex, 'to localStorage');
        } catch (error) {
          console.error('Auto-save failed:', error);
        }
      }

      updateSubmitButtonState() {
        const submitBtn = document.getElementById('submit-rating');
        if (!submitBtn) return;

        if (!this.backendAvailable) {
          submitBtn.disabled = true;
          submitBtn.textContent = 'Server Unavailable';
          return;
        }

        if (!this.widget) {
          submitBtn.disabled = true;
          submitBtn.textContent = 'Loading...';
          return;
        }

        const ratingData = this.widget.getData();
        const result = this.checkRatingDataComplete(ratingData);

        if (result.isComplete) {
          submitBtn.disabled = false;
          submitBtn.textContent = 'Save to Server';
        } else {
          submitBtn.disabled = true;
          if (result.missingDimensions.length > 0) {
            submitBtn.textContent = `Rate: ${result.missingDimensions.join(', ')}`;
          } else {
            submitBtn.textContent = 'Complete all ratings to save';
          }
        }
      }


      // Update song completion status
      updateSongCompletionStatus() {
        for (let i = 0; i < this.studyConfig.songs_to_rate.length; i++) {
          this.songCompletionStatus[i] = this.isSongCompletelyRated(i);
        }
      }

      // Called after loading ratings or submitting ratings
      async refreshSongCompletionStatus() {
        this.updateSongCompletionStatus();
        this.updateSongNavigationUI();
      }

      updateSongNavigationUI() {
        const containers = document.querySelectorAll('.song-nav-container');
        containers.forEach((container, index) => {
          const indicator = container.querySelector('.completion-indicator');
          const isComplete = this.songCompletionStatus[index];

          if (indicator) {
            indicator.textContent = isComplete ? '✓' : '○';
            indicator.style.background = isComplete ? '#10b981' : '#ef4444';
            indicator.title = isComplete ? 'Fully rated' : 'Not fully rated';
          }
        });
      }

      getStudyName() {
        const urlParams = new URLSearchParams(window.location.search);
        return urlParams.get('study_name') || 'default';
      }

      // Helper to convert backend format to widget format
      convertToWidgetFormat(backendConfig) {
        // Convert rating_dimensions array to object format
        const ratingDimensions = {};
        backendConfig.rating_dimensions.forEach(dim => {
          ratingDimensions[dim.dimension_title] = { num_values: dim.num_values };
        });

        return {
          ...backendConfig,
          rating_dimensions: ratingDimensions
        };
      }

      async init() {
        // First, check backend availability
        await this.checkBackendAvailability();

        // If backend is available, try to load study config from it
        if (this.backendAvailable) {
          const configLoaded = await this.loadStudyConfigFromBackend();

          // If config failed to load (e.g., 403/404), we already showed error messages
          if (!configLoaded) {
            // Config loading failed, we're using defaults
            // The error was already shown by loadStudyConfigFromBackend()
          }
        } else {
          this.showOfflineNotice();
          // Convert default config to widget format
          this.studyConfig = this.convertToWidgetFormat(DEFAULT_STUDY_CONFIG);

          // Update UI with study info
          document.getElementById('song-count').textContent = this.studyConfig.songs_to_rate.length;
          document.getElementById('total-songs').textContent = this.studyConfig.songs_to_rate.length;
        }

        // Build song navigation (using whatever config we have)
        this.buildSongNavigation();

        // Bind event listeners
        document.getElementById('begin-study').addEventListener('click', () => this.startRating());
        document.getElementById('submit-rating').addEventListener('click', () => this.submitRating());
        document.getElementById('download-data').addEventListener('click', () => this.downloadAllRatings());

        // Update backend status display
        this.updateBackendStatus();
      }

      async checkBackendAvailability() {
        try {
          // Note: AR_SETTINGS.API_BASE_URL already includes /api
          const response = await fetch(`${AR_SETTINGS.API_BASE_URL}`, {
            method: 'GET',
            headers: { 'Accept': 'application/json' }
          });

          this.backendAvailable = response.ok;
          this.backendChecked = true;

          if (this.backendAvailable) {
            console.log('Backend is available at:', AR_SETTINGS.API_BASE_URL);
          } else {
            console.log('Backend returned error:', response.status);
          }
        } catch (error) {
          console.log('Backend is not available:', error.message);
          this.backendAvailable = false;
          this.backendChecked = true;
        }
      }

      async loadStudyConfigFromBackend() {
        try {
          // Try to load study config from backend with participant authorization
          const response = await fetch(
            `${AR_SETTINGS.API_BASE_URL}/participants/${this.uid}/studies/${this.studyName}/config`
          );

          if (response.ok) {
            const studyConfig = await response.json();
            console.log('Loaded study config from backend:', studyConfig.name_short);

            // Convert to widget format and update
            this.studyConfig = this.convertToWidgetFormat(studyConfig);

            console.log('Study config loaded from backend and converted to widget format: ', this.studyConfig);

            // Update study info display
            document.getElementById('song-count').textContent = studyConfig.songs_to_rate.length;
            document.getElementById('total-songs').textContent = studyConfig.songs_to_rate.length;

            // Update instructions with study description if available
            if (studyConfig.description && studyConfig.description !== "Default study for music aesthetics research") {
              const instructionsDiv = document.querySelector('.instructions');
              if (instructionsDiv) {
                const studyDesc = document.createElement('p');
                studyDesc.textContent = studyConfig.description;
                studyDesc.style.fontStyle = 'italic';
                studyDesc.style.margin = '10px 0';
                instructionsDiv.insertBefore(studyDesc, instructionsDiv.firstChild);
              }
            }

            return true;

          } else if (response.status === 403) {
            // Participant not authorized for this study
            const errorData = await response.json().catch(() => ({}));
            const errorMessage = errorData.detail || "You are not authorized to participate in this study.";

            this.showOfflineNotice();
            this.showStatusMessage(errorMessage, 'error');

            // Disable the begin study button
            const beginBtn = document.getElementById('begin-study');
            if (beginBtn) {
              beginBtn.disabled = true;
              beginBtn.textContent = 'Not Authorized';
            }

            console.warn(`Participant '${this.uid}' not authorized for study '${this.studyName}'`);
            this.studyConfig = this.convertToWidgetFormat(DEFAULT_STUDY_CONFIG);
            return false;

          } else if (response.status === 404) {
            // Study not found
            console.warn(`Study '${this.studyName}' not found in backend, using default`);
            this.showStatusMessage(`Study '${this.studyName}' not found. Using demo configuration.`, 'warning');
            this.studyConfig = this.convertToWidgetFormat(DEFAULT_STUDY_CONFIG);
            return false;

          } else {
            // Other error
            console.warn('Failed to load config from backend, using defaults. Status:', response.status);
            this.showOfflineNotice();
            this.studyConfig = this.convertToWidgetFormat(DEFAULT_STUDY_CONFIG);
            return false;
          }

        } catch (error) {
          console.warn('Failed to load config from backend, using defaults:', error);
          this.showOfflineNotice();
          this.studyConfig = this.convertToWidgetFormat(DEFAULT_STUDY_CONFIG);
          return false;
        }
      }

      buildSongNavigation() {
        const songListDiv = document.getElementById('song-list');
        songListDiv.innerHTML = '';

        // Update completion status first
        this.updateSongCompletionStatus();

        this.studyConfig.songs_to_rate.forEach((song, index) => {
          const buttonContainer = document.createElement('div');
          buttonContainer.className = 'song-nav-container';
          buttonContainer.style.display = 'inline-block';
          buttonContainer.style.position = 'relative';
          buttonContainer.style.margin = '2px';

          const button = document.createElement('button');
          button.type = 'button';
          button.className = 'song-nav';
          button.textContent = `${index + 1}. ${song.display_name}`;
          button.dataset.index = index;

          if (index === this.currentSongIndex) {
            button.classList.add('active');
          }

          button.addEventListener('click', () => {
            this.loadSong(index);
          });

          // Add completion indicator
          const isComplete = this.songCompletionStatus[index];
          const indicator = document.createElement('span');
          indicator.className = 'completion-indicator';
          indicator.title = isComplete ? 'Fully rated' : 'Not fully rated';
          indicator.textContent = isComplete ? '✓' : '○';
          indicator.style.cssText = `
            position: absolute;
            top: -5px;
            right: -5px;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            font-size: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: ${isComplete ? '#10b981' : '#ef4444'};
            color: white;
            border: 1px solid white;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
            pointer-events: none;
          `;

          buttonContainer.appendChild(button);
          buttonContainer.appendChild(indicator);
          songListDiv.appendChild(buttonContainer);
        });
      }


      updateSongNavigation() {
        document.querySelectorAll('.song-nav').forEach((button, index) => {
          if (index === this.currentSongIndex) {
            button.classList.add('active');
          } else {
            button.classList.remove('active');
          }
        });
      }

      showOfflineNotice() {
        document.getElementById('backend-notice').style.display = 'block';

        // Also update the submit button text
        const submitBtn = document.getElementById('submit-rating');
        if (submitBtn) {
          submitBtn.textContent = 'Save Locally';
        }
      }

      updateBackendStatus() {
        const statusEl = document.getElementById('backend-status');
        const storageEl = document.getElementById('storage-status');

        if (!this.backendChecked) {
          statusEl.className = 'backend-status connecting';
          statusEl.textContent = 'Checking backend...';
          if (storageEl) storageEl.textContent = 'Checking connection...';
          return;
        }

        if (this.backendAvailable) {
          statusEl.className = 'backend-status online';
          statusEl.textContent = '✓ Backend connected';
          if (storageEl) storageEl.textContent = 'Ratings will be saved to server';
        } else {
          statusEl.className = 'backend-status offline';
          statusEl.textContent = '⚠ Backend offline';
          if (storageEl) storageEl.textContent = 'Ratings saved locally only';
        }
      }

      async startRating() {
        this.showPhase('rating-phase');
        await this.loadSong(this.currentSongIndex);
      }


      async loadSong(songIndex) {
        await this.autoSaveCurrentSong();
        console.log(`=== loadSong(${songIndex}) called ===`);

        if (songIndex < 0 || songIndex >= this.studyConfig.songs_to_rate.length) {
          console.error(`Invalid song index: ${songIndex}, valid range: 0-${this.studyConfig.songs_to_rate.length - 1}`);
          return;
        }

        this.currentSongIndex = songIndex;
        const song = this.studyConfig.songs_to_rate[songIndex];

        console.log(`Loading song ${songIndex}:`, song);

        // Update progress display
        document.getElementById('current-song-number').textContent = songIndex + 1;
        document.getElementById('song-status').textContent = `Currently rating: ${song.display_name}`;

        // Update navigation
        this.updateSongNavigation();

        // Clear status messages
        this.clearStatusMessages();

        // Show loading
        this.setLoading(true, true);

        try {
          // Destroy previous widget if exists
          if (this.widget) {
            console.log('Destroying previous widget...');
            try {
              this.widget.destroy();
              console.log('Widget destroyed successfully');
            } catch (e) {
              console.warn('Error destroying widget:', e);
            }
            this.widget = null;
          }

          // Clear widget container
          const widgetContainer = document.getElementById('rating-widget-container');
          console.log('Clearing widget container, current innerHTML length:', widgetContainer.innerHTML.length);
          widgetContainer.innerHTML = '';
          console.log('Widget container cleared');

          // Load existing ratings (from backend if available, otherwise from localStorage)
          console.log('Loading existing ratings...');
          const existingRatings = await this.loadExistingRatings();
          console.log('Existing ratings loaded:', existingRatings);

          console.log('Creating AudioRatingWidget...');
          // Create rating widget
          this.widget = await AudioRatingWidget.create({
            container: '#rating-widget-container',
            audioUrl: song.media_url,
            rating_dimensions: this.studyConfig.rating_dimensions,
            height: 140,
            waveColor: '#bfc8d6',
            progressColor: '#6b46c1',
            with_instructions: false,
            with_volume_slider: true,
            with_step_labels_legend: true,
            show_download_button: false,
            show_timeline: true,
            title: song.display_name
          });
          console.log('AudioRatingWidget created successfully');

          // Listen to changes from the widget
          this.widget.on('change', () => {
            console.log('Widget changed, updating submit button state');
            this.updateSubmitButtonState();
            this.updateSongCompletionStatus();
            this.updateSongNavigationUI();
          });

          // Optional: Clean up listeners when widget is destroyed
          const originalDestroy = this.widget.destroy.bind(this.widget);
          this.widget.destroy = () => {
            this.widget.off('change');
            return originalDestroy();
          };

          // Set existing data if available
          const songKey = this.getSongKey();
          console.log('Song key:', songKey);
          console.log('Existing ratings for this song:', existingRatings[songKey]);

          if (existingRatings[songKey]) {
            console.log('Setting existing data on widget...');
            this.widget.setData(existingRatings[songKey].data || existingRatings[songKey]);
            this.showStatusMessage('Loaded previously saved ratings', 'success');
            await this.refreshSongCompletionStatus();
          } else {
            console.log('No existing ratings found for this song');
          }

          this.updateSubmitButtonState();

          console.log(`=== loadSong(${songIndex}) completed successfully ===`);

        } catch (error) {
          console.error('Error loading song:', error);
          console.error('Error stack:', error.stack);
          console.error('Error details:', {
            songIndex,
            song,
            widgetExists: !!this.widget,
            studyConfig: this.studyConfig,
            ratingDimensions: this.studyConfig.rating_dimensions
          });

          this.showStatusMessage(`Error loading song "${song.display_name}". Please try again.`, 'error');
        } finally {
          this.setLoading(false, true);
          console.log(`=== loadSong(${songIndex}) finished (success or error) ===`);
        }
      }


      getSongKey() {
        const key = `${this.studyName}_song_${this.currentSongIndex}`;
        console.log(`getSongKey() returning: ${key}`);
        return key;
      }


      async loadExistingRatings() {
        const songKey = this.getSongKey();
        console.log(`loadExistingRatings() - Song key: ${songKey}, backend available: ${this.backendAvailable}`);

        if (this.backendAvailable) {
          try {
            const backendUrl = `${AR_SETTINGS.API_BASE_URL}/participants/${this.uid}/studies/${this.studyName}/songs/${this.currentSongIndex}/ratings`;
            console.log(`Fetching from backend: ${backendUrl}`);

            const response = await fetch(backendUrl, {
              method: 'GET'
            });

            console.log(`Backend response status: ${response.status}`);

            if (response.status === 404) {
              console.log('No ratings exist yet on backend');
              return this.localRatings;
            }

            if (!response.ok) {
              const errorText = await response.text();
              console.error(`Backend error ${response.status}: ${errorText}`);
              throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }

            const data = await response.json();
            console.log('Backend response data:', data);

            // Extract segments from backend response
            const backendRatings = {};
            if (data.ratings) {
              Object.keys(data.ratings).forEach(ratingName => {
                backendRatings[ratingName] = data.ratings[ratingName].segments || [];
              });
            }

            console.log('Extracted backend ratings:', backendRatings);
            return { [songKey]: { data: backendRatings, source: 'backend' } };

          } catch (error) {
            console.warn('Could not load from backend, falling back to localStorage:', error);
            return this.localRatings;
          }
        } else {
          console.log('Backend not available, using localStorage');
          return this.localRatings;
        }
      }

      loadLocalRatings() {
        try {
          const stored = localStorage.getItem(this.localStorageKey);
          return stored ? JSON.parse(stored) : {};
        } catch (error) {
          console.error('Error loading local ratings:', error);
          return {};
        }
      }

      saveLocalRatings() {
        try {
          localStorage.setItem(this.localStorageKey, JSON.stringify(this.localRatings));
          return true;
        } catch (error) {
          console.error('Error saving local ratings:', error);
          return false;
        }
      }

      async submitRating() {
        if (this.isLoading || !this.widget) return;


        if(!this.isSongCompletelyRated()) {
          const num_dimensions = Object.keys(this.studyConfig.rating_dimensions).length;
          this.showStatusMessage('Please complete ratings for all ' + num_dimensions + ' dimensions before submitting.', 'error');
          return;
        }

        const ratingData = this.widget.getData();

        if (Object.keys(ratingData).length === 0) {
          this.showStatusMessage('No ratings to save. Please rate the song first.', 'error');
          return;
        }

        this.setLoading(true, false);
        this.clearStatusMessages();

        const songKey = this.getSongKey();
        const song = this.studyConfig.songs_to_rate[this.currentSongIndex];
        const submissionTimestamp = new Date().toISOString();

        // Always save locally first
        this.localRatings[songKey] = {
          data: ratingData,
          timestamp: submissionTimestamp,
          study: this.studyName,
          songIndex: this.currentSongIndex,
          songName: song.display_name,
          songUrl: song.media_url,
          source: 'local'
        };

        const localSaved = this.saveLocalRatings();

        if (localSaved) {
          this.showStatusMessage('Rating saved locally', 'success');
          await this.refreshSongCompletionStatus();
        }

        // Try to submit to backend if available
        if (this.backendAvailable) {
          console.log('Submitting rating data to backend: ', ratingData);
          try {
            // CHANGED: New URL structure with participant in path
            const backendUrl = `${AR_SETTINGS.API_BASE_URL}/participants/${this.uid}/studies/${this.studyName}/songs/${this.currentSongIndex}/ratings`;

            console.log('Submitting to backend URL:', backendUrl);

            const response = await fetch(backendUrl, {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json'
                // REMOVED: No more X-Participant-ID header needed
              },
              body: JSON.stringify({
                timestamp: submissionTimestamp,
                ratings: ratingData
              })
            });

            if (response.ok) {
              const result = await response.json();
              const operation = response.headers.get('X-Operation') || 'created';

              this.showStatusMessage(
                `Ratings ${operation === 'created' ? 'saved' : 'updated'} on server!`,
                'success'
              );
              await this.refreshSongCompletionStatus();

            } else {
              this.showStatusMessage(
                'Saved locally, but server submission failed. Working offline.',
                'warning'
              );
            }

          } catch (error) {
            console.error('Backend submission failed:', error);
            this.showStatusMessage(
              'Saved locally. Backend temporarily unavailable.',
              'warning'
            );
          }
        }

        this.setLoading(false, false);
      }



      completeStudy() {
        const hasLocalData = Object.keys(this.localRatings).length > 0;

        if (!this.backendAvailable && hasLocalData) {
          document.getElementById('completion-message').innerHTML = `
            You have completed all songs in this study.<br>
            <strong>Important:</strong> Your ratings are saved locally only.
          `;
          document.getElementById('download-section').style.display = 'block';
        }

        this.showPhase('completion-phase');
      }

      downloadAllRatings() {
        const dataStr = JSON.stringify(this.localRatings, null, 2);
        const dataBlob = new Blob([dataStr], { type: 'application/json' });
        const url = URL.createObjectURL(dataBlob);

        const link = document.createElement('a');
        link.href = url;
        link.download = `audio_ratings_${this.studyName}_${this.uid}_${new Date().toISOString().split('T')[0]}.json`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);

        setTimeout(() => URL.revokeObjectURL(url), 100);
      }

      showPhase(phaseId) {
        // Hide all phases
        document.querySelectorAll('.study-phase').forEach(phase => {
          phase.classList.remove('active');
        });

        // Show target phase
        document.getElementById(phaseId).classList.add('active');
      }

      showStatusMessage(message, type = 'info') {
        const statusDiv = document.getElementById('status-messages');
        const messageDiv = document.createElement('div');
        messageDiv.className = `${type}-message`;
        messageDiv.textContent = message;
        statusDiv.appendChild(messageDiv);

        // Auto-remove success/warning messages after 5 seconds
        if (type === 'success' || type === 'warning') {
          setTimeout(() => {
            if (messageDiv.parentNode) messageDiv.remove();
          }, 5000);
        }
      }

      clearStatusMessages() {
        const statusDiv = document.getElementById('status-messages');
        statusDiv.innerHTML = '';
      }

      setLoading(loading, isSongLoading = false) {
        this.isLoading = loading;
        const submitBtn = document.getElementById('submit-rating');
        const loadingOverlay = document.getElementById('loading-overlay');

        if (submitBtn) {
          submitBtn.disabled = loading;
          submitBtn.textContent = loading ? 'Saving...' :
            (this.backendAvailable ? 'Save to Server' : 'Save Locally');
        }

        if (loadingOverlay) {
          if (loading && isSongLoading) {
            loadingOverlay.classList.add('active');
          } else {
            loadingOverlay.classList.remove('active');
          }
        }
      }
    }

    // Initialize study when page loads
    const study = new StudyCoordinator();
    window.study = study; // For debugging

    // Global error handling
    window.addEventListener('error', function(event) {
      console.error('Global error:', event.error);
    });

    window.addEventListener('unhandledrejection', function(event) {
      console.error('Unhandled promise rejection:', event.reason);
    });
  </script>
</body>
</html>