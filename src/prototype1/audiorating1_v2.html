<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Step-based Continuous Rating (Simplified)</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  body { font-family: system-ui, -apple-system, 'Segoe UI', Roboto, Arial; margin: 16px; }
  #container { position: relative; width: 100%; max-width: 2000px; margin: 0 auto; }
  #waveform { position: relative; background: #fafafa; border: 1px solid #ddd; height: 140px; }
  canvas#overlay { position: absolute; top: 0; left: 0; z-index: 5; pointer-events: auto; }
  .controls { margin-top: 8px; display:flex; gap:8px; align-items:center; }
  button { padding: 6px 10px; border-radius:6px; border:1px solid #bbb; background:#fff; cursor:pointer; }
  button:active{ transform: translateY(1px); }
  label { font-size:13px; color:#333; }
  #info { margin-top:8px; font-size:13px; color:#444; }
  .small { font-size:12px; color:#666; }
  #rating-legend { margin-left: 12px; display:flex; gap:6px; align-items:center; flex-wrap:wrap; }
  .legend-item { padding:4px 6px; border-radius:4px; font-size:12px; color:#fff; }
</style>
</head>
<body>
<h2>Step-based Rating Prototype (Simplified)</h2>
<p class="small">Double-click waveform to split a segment. Drag inside a segment vertically to change rating (snaps to 10 steps). Drag boundaries horizontally to move them. Right-click a split handle to delete it. Click segment to jump playback.</p>

<div id="container">
  <div id="waveform"></div>
  <canvas id="overlay"></canvas>
</div>

<div class="controls">
  <button id="play">Play</button>
  <button id="stop">Stop</button>
  <label>Step levels: <strong id="steps-label">10</strong></label>
  <div id="rating-legend"></div>
</div>

<div id="info">
  <span id="status">Loading...</span>
</div>

<script type="module">
import WaveSurfer from 'https://unpkg.com/wavesurfer.js@7.0.0/dist/wavesurfer.esm.js';

const AUDIO_URL = './demo.wav';
const INITIAL_STEPS = 10;
const MIN_RATING = 0;
const MAX_RATING = INITIAL_STEPS - 1;
const HANDLE_HIT = 8;

const waveformEl = document.getElementById('waveform');
const overlay = document.getElementById('overlay');
const playBtn = document.getElementById('play');
const stopBtn = document.getElementById('stop');
const stepsLabel = document.getElementById('steps-label');
const legend = document.getElementById('rating-legend');
const status = document.getElementById('status');

stepsLabel.textContent = INITIAL_STEPS;

const wavesurfer = WaveSurfer.create({
  container: '#waveform',
  waveColor: '#bfc8d6',
  progressColor: '#6b46c1',
  height: 140,
  scrollParent: true
});

// Color map
function colorForRating(r){
  const t = r / (MAX_RATING||1);
  const hue = 220 - (220-10)*t;
  return `hsl(${hue} 80% 50% / 0.45)`;
}
for(let r=MAX_RATING;r>=MIN_RATING;r--){
  const item=document.createElement('div');
  item.className='legend-item';
  item.style.background=colorForRating(r).replace('/ 0.45)','/1)');
  item.textContent=`${r}`;
  legend.appendChild(item);
}

// Data
let segments=[{start:0,end:1e9,value:Math.floor(INITIAL_STEPS/2)}];
const ctx = overlay.getContext('2d');

// Map time <-> x
function durationOrOne(){ const d=wavesurfer.getDuration(); return (d&&isFinite(d))?d:1; }
function timeToX(time){ return (time/durationOrOne())*overlay.width; }
function xToTime(x){ return (x/overlay.width)*durationOrOne(); }
function findSegmentIndexAtTime(time){ for(let i=0;i<segments.length;i++){ if(segments[i].start<=time&&time<=segments[i].end) return i; } return -1; }

// Resize overlay to match waveform
function resizeOverlay(){
  overlay.width = waveformEl.clientWidth;
  overlay.height = waveformEl.clientHeight;
  overlay.style.width = waveformEl.clientWidth + 'px';
  overlay.style.height = waveformEl.clientHeight + 'px';
  drawAll();
}
window.addEventListener('resize', resizeOverlay);

// Draw segments
function drawAll(){
  ctx.clearRect(0,0,overlay.width,overlay.height);
  const h = overlay.height;
  const w = overlay.width;

  // Horizontal grid
  for(let s=0;s<INITIAL_STEPS;s++){
    const y = h-(s/(INITIAL_STEPS-1))*h;
    ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(w,y);
    ctx.lineWidth = (s===Math.floor((INITIAL_STEPS-1)/2))?1.2:0.7;
    ctx.strokeStyle='rgba(0,0,0,0.06)'; ctx.stroke();
    ctx.fillStyle='rgba(0,0,0,0.6)'; ctx.font='12px system-ui, Arial';
    ctx.fillText(String(s),6,Math.max(12,y-4));
  }

  segments.forEach((seg,idx)=>{
    const x1=timeToX(seg.start), x2=timeToX(seg.end);
    const heightFromTop = (1-(seg.value/(INITIAL_STEPS-1)))*h;
    ctx.fillStyle = colorForRating(seg.value);
    ctx.fillRect(x1,heightFromTop,Math.max(2,x2-x1),h-heightFromTop);
    ctx.strokeStyle='rgba(0,0,0,0.08)'; ctx.lineWidth=1;
    ctx.strokeRect(x1+0.5,heightFromTop+0.5,Math.max(1,x2-x1-1),h-heightFromTop-1);
    ctx.fillStyle='rgba(0,0,0,0.85)'; ctx.fillText(`${seg.value}`,x1+6,Math.max(12,heightFromTop+12));
    if(idx>0){ ctx.fillStyle='rgba(0,0,0,0.6)'; ctx.fillRect(x1-1,0,2,h); }
  });

  // Playback cursor
  if(wavesurfer.isReady){
    const t = wavesurfer.getCurrentTime();
    const x = timeToX(t);
    ctx.beginPath(); ctx.moveTo(x+0.5,0); ctx.lineTo(x+0.5,h);
    ctx.strokeStyle='rgba(0,0,0,0.15)'; ctx.lineWidth=1; ctx.stroke();
  }
}

// Interaction
let pointerDown=false,activeSegIndex=null,activeHandle=null;

function hitTestHandle(x){
  const time=xToTime(x);
  for(let i=1;i<segments.length;i++){
    const bx = timeToX(segments[i].start);
    if(Math.abs(bx-x)<=HANDLE_HIT) return i;
  }
  return null;
}

overlay.addEventListener('pointerdown',ev=>{
  ev.preventDefault();
  const rect = overlay.getBoundingClientRect();
  const x = ev.clientX-rect.left;
  const y = ev.clientY-rect.top;
  pointerDown=true;

  const handleIdx = hitTestHandle(x);
  if(handleIdx!==null){ activeHandle=handleIdx; overlay.setPointerCapture(ev.pointerId); return; }

  const si=findSegmentIndexAtTime(xToTime(x));
  if(si>=0){ activeSegIndex=si; overlay.setPointerCapture(ev.pointerId); wavesurfer.setCurrentTime(xToTime(x)); }
  drawAll();
});

overlay.addEventListener('pointermove',ev=>{
  if(!pointerDown) return;
  const rect=overlay.getBoundingClientRect();
  const x=ev.clientX-rect.left;
  const y=ev.clientY-rect.top;

  if(activeHandle!==null){
    const leftSeg=segments[activeHandle-1], rightSeg=segments[activeHandle];
    const newBoundary = Math.max(leftSeg.start+0.02, Math.min(rightSeg.end-0.02, xToTime(x)));
    leftSeg.end=newBoundary; rightSeg.start=newBoundary; drawAll(); return;
  }
  if(activeSegIndex!==null){
    const seg=segments[activeSegIndex];
    let raw=Math.round((1-(y/overlay.height))*(INITIAL_STEPS-1));
    seg.value=Math.max(MIN_RATING, Math.min(MAX_RATING, raw)); drawAll(); return;
  }
});

overlay.addEventListener('pointerup',ev=>{ pointerDown=false; activeSegIndex=null; activeHandle=null; drawAll(); });

// Double-click split
overlay.addEventListener('dblclick',ev=>{
  ev.preventDefault();
  const x = ev.clientX - overlay.getBoundingClientRect().left;
  const time = xToTime(x);
  const si = findSegmentIndexAtTime(time);
  if(si===-1) return;
  const seg=segments[si];
  if((time-seg.start)<0.08 || (seg.end-time)<0.08) return;
  segments.splice(si+1,0,{start:time,end:seg.end,value:seg.value});
  seg.end=time; drawAll();
});

// Right-click merge
overlay.addEventListener('contextmenu',ev=>{
  ev.preventDefault();
  const x = ev.clientX - overlay.getBoundingClientRect().left;
  const handleIdx = hitTestHandle(x);
  if(handleIdx!==null){
    const left = segments[handleIdx-1], right = segments[handleIdx];
    left.end = right.end; segments.splice(handleIdx,1); drawAll();
  }
});

// Playback
playBtn.addEventListener('click',()=>{ wavesurfer.playPause(); playBtn.textContent=wavesurfer.isPlaying()?'Pause':'Play'; });
stopBtn.addEventListener('click',()=>{ wavesurfer.stop(); playBtn.textContent='Play'; });

wavesurfer.load(AUDIO_URL);
wavesurfer.on('ready',()=>{
  if(segments.length===1) segments[0].end=wavesurfer.getDuration();
  resizeOverlay();
  status.textContent=`Duration: ${wavesurfer.getDuration().toFixed(2)}s`;
  wavesurfer.isReady=true;
  requestAnimationFrame(drawAll);
});
</script>
</body>
</html>
